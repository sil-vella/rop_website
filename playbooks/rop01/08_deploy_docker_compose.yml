---
- name: Deploy Docker Compose Application
  hosts: "{{ vm_name }}_user"
  become: true
  vars:
    app_dir: "/opt/apps/reignofplay/dutch"
    data_dir: "/opt/apps/reignofplay/dutch/data"
    compose_file: "docker-compose.yml"
    vps_user: "{{ vm_name }}_user"
  tasks:
    - name: Create application directory structure
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ app_dir }}"
        - "{{ app_dir }}/secrets"
        - "{{ data_dir }}/mongodb"
        - "{{ data_dir }}/redis"
        - "{{ data_dir }}/prometheus/config"
        - "{{ data_dir }}/prometheus/storage"
        - "{{ data_dir }}/grafana"
        - "{{ data_dir }}/grafana/provisioning"
        - "{{ data_dir }}/grafana/dashboards"

    - name: Sync Grafana provisioning configuration (datasources, dashboards providers)
      copy:
        src: "{{ playbook_dir }}/../../python_base_04/grafana/provisioning/"
        dest: "{{ data_dir }}/grafana/provisioning/"
        mode: '0644'
      register: grafana_provisioning_sync

    - name: Sync Grafana dashboard JSON definitions
      copy:
        src: "{{ playbook_dir }}/../../python_base_04/grafana/dashboards/"
        dest: "{{ data_dir }}/grafana/dashboards/"
        mode: '0644'
      register: grafana_dashboards_sync

    - name: Ensure secrets directory exists on VPS (0755 so Bitnami MongoDB UID 1001 can traverse to read mongodb_* secret files)
      file:
        path: "{{ app_dir }}/secrets"
        state: directory
        mode: '0755'
        owner: "{{ vps_user }}"
        group: "{{ vps_user }}"

    - name: Get list of secret files
      find:
        paths: "{{ playbook_dir }}/../../python_base_04/secrets"
        patterns: "*"
        file_type: file
      register: secret_files_local

    - name: Copy secret files to VPS (only if missing or different, mode 0600)
      copy:
        src: "{{ item.path }}"
        dest: "{{ app_dir }}/secrets/{{ item.path | basename }}"
        mode: '0600'
        owner: "{{ vps_user }}"
        group: "{{ vps_user }}"
        force: no
      loop: "{{ secret_files_local.files }}"
      loop_control:
        label: "{{ item.path | basename }}"
      when: item.path is defined
      register: secret_files_copy_result

    - name: Display secret files copy summary
      debug:
        msg: |
          Secret files sync summary:
          - Total files checked: {{ secret_files_local.files | length }}
          - Files copied: {{ secret_files_copy_result.results | selectattr('changed', 'equalto', true) | list | length }}
          - Files skipped (unchanged): {{ secret_files_copy_result.results | selectattr('changed', 'equalto', false) | list | length }}
      when: secret_files_copy_result is defined

    - name: Ensure Dart backend service key exists locally (for copy)
      stat:
        path: "{{ playbook_dir }}/../../python_base_04/secrets/dart_backend_service_key"
      register: dart_service_key_local

    - name: Copy Dart backend service key to VPS (Dart server → Flask API auth)
      copy:
        src: "{{ playbook_dir }}/../../python_base_04/secrets/dart_backend_service_key"
        dest: "{{ app_dir }}/secrets/dart_backend_service_key"
        mode: '0644'
        owner: "{{ vps_user }}"
        group: "{{ vps_user }}"
        force: yes
      when: dart_service_key_local.stat.exists | default(false)

    - name: Get VPS app user UID and GID (for Redis/MongoDB container user)
      shell: "getent passwd {{ vps_user }} | cut -d: -f3,4"
      register: vps_app_id
      changed_when: false

    - name: Set VPS app UID/GID facts
      set_fact:
        vps_app_uid: "{{ vps_app_id.stdout.split(':')[0] }}"
        vps_app_gid: "{{ vps_app_id.stdout.split(':')[1] }}"
      when: vps_app_id.stdout is defined and vps_app_id.stdout != ""

    - name: Create .env with VPS_APP_UID and VPS_APP_GID for compose
      copy:
        content: |
          VPS_APP_UID={{ vps_app_uid | default('1000') }}
          VPS_APP_GID={{ vps_app_gid | default('1000') }}
        dest: "{{ app_dir }}/.env"
        mode: '0640'
        owner: "{{ vps_user }}"
        group: "{{ vps_user }}"
      when: vps_app_uid is defined and vps_app_gid is defined

    - name: Ensure Redis data dir is owned by VPS app user (Redis runs as this UID)
      file:
        path: "{{ data_dir }}/redis"
        state: directory
        mode: '0755'
        owner: "{{ vps_user }}"
        group: "{{ vps_user }}"

    - name: Ensure MongoDB data dir is owned by UID 1001 (Bitnami MongoDB default user)
      file:
        path: "{{ data_dir }}/mongodb"
        state: directory
        mode: '0755'
        owner: "1001"
        group: "1001"

    - name: Recursively fix ownership of Redis data
      command: "chown -R {{ vps_user }}:{{ vps_user }} {{ data_dir }}/redis"
      changed_when: true

    - name: Recursively fix ownership of MongoDB data
      command: "chown -R 1001:1001 {{ data_dir }}/mongodb"
      changed_when: true

    - name: Make MongoDB secret files readable by Bitnami container user (1001)
      file:
        path: "{{ app_dir }}/secrets/{{ item }}"
        mode: '0644'
      loop:
        - mongodb_root_password
        - mongodb_user_password
      ignore_errors: true

    - name: Copy docker-compose.yml to server
      copy:
        src: "{{ playbook_dir }}/../../{{ compose_file }}"
        dest: "{{ app_dir }}/{{ compose_file }}"
        mode: '0644'
        remote_src: false

    - name: Create minimal Prometheus configuration file
      copy:
        content: |
          global:
            scrape_interval: 15s
            evaluation_interval: 15s

          scrape_configs:
            - job_name: 'flask-app'
              static_configs:
                - targets: ['dutch_flask-external:5001']
              metrics_path: '/metrics'
        dest: "{{ data_dir }}/prometheus/config/prometheus.yml"
        mode: '0644'

    - name: Verify docker-compose.yml was copied
      stat:
        path: "{{ app_dir }}/{{ compose_file }}"
      register: compose_file_stat

    - name: Display docker-compose.yml location
      debug:
        msg: |
          ============================================
          Docker Compose file deployed successfully!
          ============================================
          Location: {{ app_dir }}/{{ compose_file }}
          
          To start the services, SSH into the server and run:
          cd {{ app_dir }}
          docker compose up -d
          
          To view logs:
          docker compose logs -f
          
          To stop services:
          docker compose down
          ============================================

    - name: Check if Docker Compose is available
      shell: sg docker -c "docker compose version"
      register: docker_compose_check
      changed_when: false
      failed_when: false

    - name: Display Docker Compose version
      debug:
        msg: "{{ docker_compose_check.stdout }}"
      when: docker_compose_check.rc is defined and docker_compose_check.rc == 0

    - name: Validate docker-compose.yml syntax
      shell: sg docker -c "docker compose -f {{ app_dir }}/{{ compose_file }} config"
      register: compose_validate
      changed_when: false
      failed_when: false
      when: docker_compose_check.rc is defined and docker_compose_check.rc == 0

    - name: Display validation result
      debug:
        msg: |
          Docker Compose file validation:
          {{ compose_validate.stdout if (compose_validate.rc is defined and compose_validate.rc == 0) else 'Validation failed - check the error above' }}
      when: compose_validate is defined and compose_validate.rc is defined and compose_validate.rc == 0

    - name: Display warning if validation failed
      debug:
        msg: |
          ⚠ WARNING: Docker Compose file validation failed.
          Please check the docker-compose.yml file for errors.
          Error: {{ compose_validate.stderr | default('Unknown error') }}
      when: compose_validate is defined and compose_validate.rc is defined and compose_validate.rc != 0

    - name: Prompt for interactive docker compose run
      pause:
        prompt: |
          ============================================
          Ready to start Docker Compose services?
          ============================================
          The docker-compose.yml file has been deployed to:
          {{ app_dir }}/{{ compose_file }}
          
          Would you like to start the services now?
          (This will run: docker compose up -d)
          
          Press Enter to continue, or Ctrl+C to cancel.
          ============================================
      register: start_prompt
      when: ansible_check_mode == False

    - name: Pull latest Docker images
      shell: sg docker -c "cd {{ app_dir }} && docker compose -f {{ compose_file }} pull"
      register: compose_pull_result
      when: start_prompt is defined and start_prompt.user_input is defined

    - name: Start Docker Compose services
      shell: sg docker -c "cd {{ app_dir }} && docker compose -f {{ compose_file }} up -d"
      register: compose_up_result
      when: start_prompt is defined and start_prompt.user_input is defined

    - name: Display service startup result
      debug:
        msg: "{{ compose_up_result.stdout_lines | default([]) }}"
      when: compose_up_result is defined and compose_up_result.stdout_lines is defined

    - name: Wait for services to be ready
      wait_for:
        host: localhost
        port: "{{ item.port }}"
        delay: 5
        timeout: 30
      loop:
        - { port: 5001, name: "Flask App" }
        - { port: 27018, name: "MongoDB" }
        - { port: 6380, name: "Redis" }
      failed_when: false
      when: compose_up_result is defined and compose_up_result.changed | default(false)

    - name: Restart Grafana container if provisioning changed
      shell: sg docker -c "cd {{ app_dir }} && docker compose -f {{ compose_file }} restart dutch_grafana"
      when:
        - compose_up_result is defined and compose_up_result.changed | default(false)
        - grafana_provisioning_sync is defined and grafana_provisioning_sync.changed | default(false) or
          grafana_dashboards_sync is defined and grafana_dashboards_sync.changed | default(false)

    - name: Check running containers
      shell: sg docker -c "cd {{ app_dir }} && docker compose -f {{ compose_file }} ps"
      register: container_status
      changed_when: false
      when: compose_up_result is defined and compose_up_result.changed | default(false)

    - name: Display container status
      debug:
        msg: |
          ============================================
          Container Status:
          ============================================
          {{ container_status.stdout | default('Containers not started') }}
          ============================================
      when: container_status is defined

    - name: Display completion message
      debug:
        msg: |
          ============================================
          ✓ DEPLOYMENT COMPLETE!
          ============================================
          Docker Compose file: {{ app_dir }}/{{ compose_file }}
          
          Services should be starting up. Check status with:
          cd {{ app_dir }}
          docker compose ps
          docker compose logs -f
          
          To stop all services:
          docker compose down
          ============================================
      when: compose_up_result is defined and compose_up_result.changed | default(false)
